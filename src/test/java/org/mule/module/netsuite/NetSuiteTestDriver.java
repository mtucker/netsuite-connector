/**
 * Mule NetSuite Cloud Connector
 *
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 */

/**
 * This file was automatically generated by the Mule Cloud Connector Development Kit
 */

package org.mule.module.netsuite;

import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.*;

import org.mule.api.lifecycle.InitialisationException;

import com.netsuite.webservices.lists.accounting_2010_2.types.ItemWeightUnit;
import com.netsuite.webservices.lists.employees_2010_2.Employee;
import com.netsuite.webservices.platform.core_2010_2.DeletedRecord;
import com.netsuite.webservices.platform.core_2010_2.RecordRef;
import com.netsuite.webservices.platform.core_2010_2.types.CalendarEventAttendeeResponse;
import com.netsuite.webservices.platform.core_2010_2.types.RecordType;
import com.netsuite.webservices.transactions.financial_2010_2.types.BudgetBudgetType;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

import javax.validation.constraints.AssertTrue;

import org.junit.Before;
import org.junit.Test;

@SuppressWarnings("serial")
public class NetSuiteTestDriver
{
    // FIXME the file path of the wsdl is embedded in the generated classes
    private NetSuiteCloudConnector connector;

    @Before
    public void setup() throws InitialisationException
    {
        connector = new NetSuiteCloudConnector();
        connector.setAccount(System.getenv("netsuiteAccount"));
        connector.setEmail(System.getenv("netsuiteEmail"));
        connector.setPassword(System.getenv("netsuitePassword"));
        connector.setRoleId("3");
        connector.initialise();
    }

    @Test
    public void getServerTime() throws Exception
    {
        assertThat(connector.GetServerTime(), instanceOf(Date.class));
    }

    @Test
    public void getRecords() throws Exception
    {
        assertFalse(connector.getRecords(RecordType.CURRENCY).isEmpty());
    }

    @Test
    public void attachAndDetachEntity()
    {
        // TODO file attachements?
        RecordRef employee = null, campaign = null;
        try
        {
            employee = createEmployeeJohnDoe();
            campaign = connector.addRecord(RecordType.CONTACT, new HashMap<String, Object>()
            {
                {
                    put("title", "The Campaignola");

                }
            });
            connector.attachRecord(RecordType.EMPLOYEE, employee.getInternalId(), RecordIdType.INTERNAL,
                RecordType.CAMPAIGN, campaign.getInternalId(), RecordIdType.INTERNAL, null, null, null);
            connector.detachRecord(RecordType.EMPLOYEE, employee.getInternalId(), RecordIdType.INTERNAL,
                RecordType.CAMPAIGN, campaign.getInternalId(), RecordIdType.INTERNAL);
        }
        finally
        {
            if (employee != null)
            {
                connector.deleteRecord(RecordType.EMPLOYEE, employee.getInternalId(), RecordIdType.INTERNAL);
            }
            if (campaign != null)
            {
                connector.deleteRecord(RecordType.CAMPAIGN, campaign.getInternalId(), RecordIdType.INTERNAL);
            }
        }
    }

    /**
     * Test that a record can be created and updated, and that the modification are
     * persistent
     */
    @Test
    public void updateRecord() throws Exception
    {

        RecordRef recordRef = createEmployeeJohnDoe();
        try
        {
            connector.updateRecord(RecordType.EMPLOYEE, recordRef.getInternalId(), RecordIdType.INTERNAL,
                new HashMap<String, Object>()
                {
                    {
                        put("fax", "159-945-57");
                    }
                });
            Employee record = (Employee) connector.getRecord(RecordType.EMPLOYEE, recordRef.getInternalId(),
                RecordIdType.INTERNAL);
            assertEquals("159-945-57", record.getFax());
        }
        finally
        {
            connector.deleteRecord(RecordType.EMPLOYEE, recordRef.getInternalId(), RecordIdType.INTERNAL);
        }
    }

    @Test
    public void getBudgetExchangeRate()
    {
        final RecordRef subsidiary = connector.addRecord(RecordType.SUBSIDIARY, new HashMap<String, Object>()
        {
            {
                put("Name", "ACME");
            }
        });
        RecordRef budget = connector.addRecord(RecordType.BUDGET, new HashMap<String, Object>()
        {
            {
                put("amount", 150000.00);
                put("subsidiary", subsidiary);
                put("budgetType", BudgetBudgetType.LOCAL);
            }
        });
        List<Object> budgetExchangeRate = connector.getBudgetExchangeRate(budget.getInternalId(),
            RecordIdType.INTERNAL, subsidiary.getInternalId(), RecordIdType.INTERNAL, null, null);
        assertNotNull(budgetExchangeRate);
    }

    @Test
    public void getConsolidatedExchangeRate()
    {
        List<Object> consolidatedExchangeRate = connector.getConsolidatedExchangeRate("10",
            RecordIdType.INTERNAL, "65", RecordIdType.INTERNAL, null, null);
        assertNotNull(consolidatedExchangeRate);
        // TODO
    }

    
    @Test
    public void getCustomizationId()
    {
        List<Object> customizations = connector.getCustomizationId(RecordType.ACCOUNT, false);
        assertNotNull(customizations);
        // TODO test more in depth
        //TODO change to GetCustomizationType  and use CRM_CUSTOM_FIELD in example
    }

    /**
     * Test that deleted records are retrieved in the getDeletedRecords query 
     */
    @Test
    public void getDeletedEntity()
    {
        // TODO perhaps it would be also a good idea to expose a more object oriented
        // instead of string oriented date query
        Date serverTime = connector.GetServerTime();
        RecordRef recordRef = createEmployeeJohnDoe();
        connector.deleteRecord(RecordType.EMPLOYEE, recordRef.getInternalId(), RecordIdType.INTERNAL);
        //TODO rename to getDeletedRecords
        List<Object> deletedRecords = connector.getDeletedRecord(RecordType.EMPLOYEE, // 
            "after(dateTime('" + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(serverTime) + "','yyyy-MM-dd HH:mm:ss'))");
        assertEquals(1, deletedRecords.size());
        //TODO cast
    }

    /**
     * Test that existing records can be fetched
     */
    @Test
    public void getRecord()
    {
        RecordRef campaign = connector.addRecord(RecordType.CAMPAIGN, new HashMap<String, Object>()
        {
            {
                put("title", "The Campagniola");
            }
        });
        try
        {
            connector.getRecord(RecordType.CAMPAIGN, campaign.getInternalId(), RecordIdType.INTERNAL);
        }
        finally
        {
            connector.deleteRecord(RecordType.CAMPAIGN, campaign.getInternalId(), RecordIdType.INTERNAL);
        }
    }

    /**
     * Tests that simple searches that involve multiple record attributes work properly 
     */
    @Test
    public void findRecordSimpleSearch() throws Exception
    {
        List<Object> employees = findJohnDoe();
        assertTrue(employees.isEmpty());

        RecordRef ref = createEmployeeJohnDoe();
        try
        {
            assertEquals(1, findJohnDoe().size());
            assertEquals(0, findMaryDoe().size());
        }
        finally
        {
            connector.deleteRecord(RecordType.EMPLOYEE, ref.getInternalId(), RecordIdType.INTERNAL);
        }
    }

    private List<Object> findJohnDoe()
    {
        return connector.findRecord(RecordType.EMPLOYEE, "is(firstName, 'John'), is(lastName, 'Doe')");
    }

    private List<Object> findMaryDoe()
    {
        return connector.findRecord(RecordType.EMPLOYEE, "is(firstName, 'Mary'), is(lastName, 'Doe')");
    }

    @Test
    public void findRecordJoinedSearch() throws Exception
    {
        assertNotNull(connector.findRecord(RecordType.EMPLOYEE,
            "is(email, 'john.doe@foobar.com'), is(userNotes.title, 'A note')"));
    }

    /**
     * Test that item availability queries work for existing inventory items
     */
    @Test
    public void getItemAvailability()
    {
        RecordRef inventoryItem = connector.addRecord(RecordType.INVENTORY_ITEM,
            new HashMap<String, Object>()
            {
                {
                    put("isTaxable", false);
                    put("isOnline", true);
                    put("weight", 59.10);
                    put("weightUnit", ItemWeightUnit.G);
                    put("displayName", "A thing");
                    put("storeDisplayName", "A thing");
                    put("vendorName", "A vendor");
                    put("itemId", "Item");
                }
            });
        try
        {
            assertNotNull(connector.getItemAvailability(RecordType.INVENTORY_ITEM,
                inventoryItem.getInternalId(), RecordIdType.INTERNAL, null));
        }
        finally
        {
            connector.deleteRecord(RecordType.INVENTORY_ITEM, inventoryItem.getInternalId(),
                RecordIdType.INTERNAL);
        }
    }

    @Test
    public void getSavedSearch()
    {
        connector.getSavedSearch(RecordType.CONTACT);
    }

    /**
     * Tests that the invitation status of a calendar event can be updated
     */
    @Test
    public void updateInviteeStatus()
    {
        RecordRef event = connector.addRecord(RecordType.CALENDAR_EVENT, new HashMap<String, Object>()
        {
            {
                put("sendMail", false);
                put("title", "An importat event");
                put("location", "Pekin");
                put("startDate", new Date());
            }
        });
        connector.updateInviteeStatus(event.getInternalId(), RecordIdType.INTERNAL,
            CalendarEventAttendeeResponse.DECLINED);
    }

    private RecordRef createEmployeeJohnDoe()
    {
        RecordRef recordRef = connector.addRecord(RecordType.EMPLOYEE, new HashMap<String, Object>()
        {
            {
                put("fax", "159-945-56");
                put("firstName", "John");
                put("lastName", "Doe");
                put("salesRep", true);
                put("email", "john.doe@foobar.com");

            }
        });
        return recordRef;
    }
}
