/**
 * Mule NetSuite Cloud Connector
 *
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 */

/**
 * This file was automatically generated by the Mule Cloud Connector Development Kit
 */

package org.mule.module.netsuite;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

import net.sf.staccatocommons.collections.stream.Streams;

import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.mule.api.lifecycle.InitialisationException;

import com.netsuite.webservices.documents.filecabinet_2010_2.types.TextFileEncoding;
import com.netsuite.webservices.lists.accounting_2010_2.types.ItemWeightUnit;
import com.netsuite.webservices.lists.employees_2010_2.Employee;
import com.netsuite.webservices.lists.employees_2010_2.types.Gender;
import com.netsuite.webservices.platform.core_2010_2.AsyncStatusResult;
import com.netsuite.webservices.platform.core_2010_2.Record;
import com.netsuite.webservices.platform.core_2010_2.RecordRef;
import com.netsuite.webservices.platform.core_2010_2.types.AsyncStatusType;
import com.netsuite.webservices.transactions.financial_2010_2.types.BudgetBudgetType;

@SuppressWarnings("serial")
public class NetSuiteTestDriver
{
    private NetSuiteCloudConnector connector;

    @Before
    public void setup() throws InitialisationException
    {
        connector = new NetSuiteCloudConnector();
        connector.setAccount(System.getenv("netsuiteAccount"));
        connector.setEmail(System.getenv("netsuiteEmail"));
        connector.setPassword(System.getenv("netsuitePassword"));
        connector.setRoleId("3");
        connector.init();
    }

    @Test
    public void findEmployee() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.EMPLOYEE, null).iterator().hasNext();
    }

    @Test
    public void findCustomer() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.CUSTOMER, "is(firstName, 'lala')").iterator().hasNext();
    }

    @Test
    public void findAccountingPeriod() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.ACCOUNTING_PERIOD, null).iterator().hasNext();
    }

    @Test
    public void findAccount() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.ACCOUNT, null).iterator().hasNext();
    }

    @Test
    public void findBin() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.BIN, null).iterator().hasNext();
    }

    @Test
    public void findBudget() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.BUDGET, null).iterator().hasNext();
    }

    @Test
    public void findCalendarEvent() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.CALENDAR_EVENT, null).iterator().hasNext();
    }

    @Test
    public void findCampaign() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.CAMPAIGN, null).iterator().hasNext();
    }

    @Test
    public void findClassification() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.CLASSIFICATION, null).iterator().hasNext();
    }

    @Test
    public void findDepartment() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.DEPARTMENT, null).iterator().hasNext();
    }

    @Test
    public void findFolder() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.FOLDER, null).iterator().hasNext();
    }

    @Test
    public void findContact() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.CONTACT, null).iterator().hasNext();
    }

    @Test
    public void findVendor() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.VENDOR, null).iterator().hasNext();
    }

    @Test
    public void findTask() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.TASK, null).iterator().hasNext();
    }

    @Test
    public void findSubsidiary() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.SUBSIDIARY, null).iterator().hasNext();
    }

    @Test
    public void findJob() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.JOB, null).iterator().hasNext();
    }

    @Test
    public void findIssue() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.ISSUE, null).iterator().hasNext();
    }

    @Test
    public void findItem() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.ITEM, null).iterator().hasNext();
    }

    @Test
    public void findMessage() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.MESSAGE, null).iterator().hasNext();
    }

    @Test
    public void findLocation() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.LOCATION, null).iterator().hasNext();
    }

    @Test
    public void findSolution() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.SOLUTION, null).iterator().hasNext();
    }

    @Test
    public void findNote() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.NOTE, null).iterator().hasNext();
    }


    @Test
    public void findOpportunity() throws Exception
    {
        connector.findRecords(SearchRecordTypeEnum.OPPORTUNITY, null).iterator().hasNext();
    }

    /**
     * Tests searching using multi enum selects
     */
    @Test
    public void findRecordMultiSelectSearch() throws Exception
    {
        Iterable<Record> employees = findJohnDoe();
        assertFalse(employees.iterator().hasNext());

        RecordRef ref = createEmployeeJohnDoe();
        try
        {
            assertEquals(1,
                getLength(connector.findRecords(SearchRecordTypeEnum.EMPLOYEE, "anyOf(internalId, [ internal('" + ref.getInternalId() + "') ] )")));
        }
        finally
        {
            connector.deleteRecord(RecordTypeEnum.EMPLOYEE, ref.getInternalId(), RecordIdType.INTERNAL);
        }
    }



    /**
     * Tests searching using multi enum selects. This tests assumes there are
     * employees in the server
     */
    @Test
    public void findRecordMultiEnumSelectSearch() throws Exception
    {
        int length = getLength(connector.findRecords(SearchRecordTypeEnum.EMPLOYEE, null));
        assertTrue(length > 0);

        assertEquals(length, //
            getLength(connector.findRecords(SearchRecordTypeEnum.EMPLOYEE, "noneOf(globalSubscriptionStatus, [ _softOptIn, _confirmedOptOut ])")) +
            getLength(connector.findRecords(SearchRecordTypeEnum.EMPLOYEE, "anyOf(globalSubscriptionStatus, [ _softOptIn, _confirmedOptOut ])")));
    }

    @Test
    public void getServerTime() throws Exception
    {
        assertThat(connector.GetServerTime(), instanceOf(Date.class));
    }

    @Test
    public void getRecords() throws Exception
    {
        assertFalse(connector.getRecords(RecordTypeEnum.CURRENCY).isEmpty());
    }

    @Test
    public void attachAndDetachEntity()
    {
        RecordRef file = null, folder = null, employee = createEmployeeJohnDoe();
        try
        {
            folder = createFolder();
            file = createFile(folder);
            connector.attachRecord(RecordTypeEnum.FILE, file.getInternalId(), RecordIdType.INTERNAL,
                RecordTypeEnum.EMPLOYEE, employee.getInternalId(), RecordIdType.INTERNAL, null, null, null);
            connector.detachRecord(RecordTypeEnum.FILE, file.getInternalId(), RecordIdType.INTERNAL,
                RecordTypeEnum.EMPLOYEE, employee.getInternalId(), RecordIdType.INTERNAL);
        }
        finally
        {
            connector.deleteRecord(RecordTypeEnum.EMPLOYEE, employee.getInternalId(), RecordIdType.INTERNAL);
            if (file != null)
            {
                connector.deleteRecord(RecordTypeEnum.FILE, file.getInternalId(), RecordIdType.INTERNAL);
            }
            if (folder != null)
            {
                connector.deleteRecord(RecordTypeEnum.FOLDER, folder.getInternalId(), RecordIdType.INTERNAL);
            }
        }
    }

    private RecordRef createFolder()
    {
        return connector.addRecord(RecordTypeEnum.FOLDER, new HashMap<String, Object>()
        {
            {
                put("isPrivate", false);
                put("name", "Folder1");
            }
        });
    }

    private RecordRef createFile(final RecordRef folder)
    {
        return connector.addRecord(RecordTypeEnum.FILE, new HashMap<String, Object>()
        {
            {
                put("isPrivate", false);
                put("description", "File1.txt");
                put("textFileEncoding", TextFileEncoding.UTF_8);
                put("name", "foobar");
                put("content", "foo bar".getBytes());
                put("folder", folder);
            }
        });
    }

    /**
     * Test creating a file using the
     * {@link NetSuiteCloudConnector#addFile(java.util.Map, Object, String, String, RecordIdType)}
     * method
     */
    @Test
    public void addFile() throws Exception
    {
        RecordRef file = null, folder = createFolder();
        try
        {
            file = connector.addFile(null, "foobar", "File2.txt", folder.getInternalId(),
                RecordIdType.INTERNAL);
        }
        finally
        {
            if (file != null)
            {
                connector.deleteRecord(RecordTypeEnum.FILE, file.getInternalId(), RecordIdType.INTERNAL);
            }
            connector.deleteRecord(RecordTypeEnum.FOLDER, folder.getInternalId(), RecordIdType.INTERNAL);
        }
    }

    /**
     * Test that a record can be created and updated, and that the modification are
     * persistent
     */
    @Test
    public void updateRecord() throws Exception
    {

        RecordRef recordRef = createEmployeeJohnDoe();
        try
        {
            connector.updateRecord(RecordTypeEnum.EMPLOYEE, recordRef.getInternalId(), RecordIdType.INTERNAL,
                new HashMap<String, Object>()
                {
                    {
                        put("fax", "159-945-57");
                    }
                });
            Employee record = (Employee) connector.getRecord(RecordTypeEnum.EMPLOYEE, recordRef.getInternalId(),
                RecordIdType.INTERNAL);
            assertEquals("159-945-57", record.getFax());
        }
        finally
        {
            connector.deleteRecord(RecordTypeEnum.EMPLOYEE, recordRef.getInternalId(), RecordIdType.INTERNAL);
        }
    }

    @Ignore
    @Test
    public void getBudgetExchangeRate()
    {
        final RecordRef subsidiary = connector.addRecord(RecordTypeEnum.SUBSIDIARY, new HashMap<String, Object>()
        {
            {
                put("name", "ACME");
            }
        });
        RecordRef budget = connector.addRecord(RecordTypeEnum.BUDGET, new HashMap<String, Object>()
        {
            {
                put("amount", 150000.00);
                put("subsidiary", subsidiary);
                put("budgetType", BudgetBudgetType.LOCAL);
            }
        });
        List<Object> budgetExchangeRate = connector.getBudgetExchangeRates(budget.getInternalId(),
            RecordIdType.INTERNAL, subsidiary.getInternalId(), RecordIdType.INTERNAL, null, null);
        assertNotNull(budgetExchangeRate);
    }

    @Test
    public void getCustomizationId()
    {
        List<Object> customizations = connector.getCustomizationIds(GetCustomizationTypeEnum.CRM_CUSTOM_FIELD,
            false);
        assertNotNull(customizations);
        assertFalse(customizations.isEmpty());
    }

    /**
     * Test that deleted records are retrieved in the getDeletedRecords query, using
     * the string oriented style
     */
    @Test
    public void getDeletedEntityStringExpression()
    {
        Date serverTime = connector.GetServerTime();
        RecordRef recordRef = createEmployeeJohnDoe();
        connector.deleteRecord(RecordTypeEnum.EMPLOYEE, recordRef.getInternalId(), RecordIdType.INTERNAL);
        List<Object> deletedRecords = connector.getDeletedRecords(RecordTypeEnum.EMPLOYEE, //
            "after(dateTime('" + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(serverTime)
                            + "','yyyy-MM-dd HH:mm:ss'))", null, null, null);
        assertEquals(1, deletedRecords.size());
    }

    /**
     * Test that deleted records are retrieved in the getDeletedRecords query, using
     * the simple style.
     */
    @Test
    public void getDeletedEntitySimpleExpression()
    {
        Date serverTime = connector.GetServerTime();
        RecordRef recordRef = createEmployeeJohnDoe();
        connector.deleteRecord(RecordTypeEnum.EMPLOYEE, recordRef.getInternalId(), RecordIdType.INTERNAL);
        List<Object> deletedRecords = connector.getDeletedRecords(RecordTypeEnum.EMPLOYEE, null, serverTime,
            null, SearchDateFieldOperatorEnum.AFTER);
        assertEquals(1, deletedRecords.size());
    }

    /**
     * Test that existing records can be fetched
     */
    @Test
    public void getRecord()
    {
        RecordRef campaign = connector.addRecord(RecordTypeEnum.CAMPAIGN, new HashMap<String, Object>()
        {
            {
                put("title", "The Campagniola");
            }
        });
        try
        {
            connector.getRecord(RecordTypeEnum.CAMPAIGN, campaign.getInternalId(), RecordIdType.INTERNAL);
        }
        finally
        {
            connector.deleteRecord(RecordTypeEnum.CAMPAIGN, campaign.getInternalId(), RecordIdType.INTERNAL);
        }
    }

    private int getLength(Iterable<?> results)
    {
        return Streams.from(results).size();
    }

    /**
     * Tests that simple searches that involve multiple record attributes work
     * properly
     */
    @Test
    public void findRecordSimpleSearch() throws Exception
    {
        Iterable<Record> employees = findJohnDoe();
        assertFalse(employees.iterator().hasNext());

        RecordRef ref = createEmployeeJohnDoe();
        try
        {
            assertTrue(findJohnDoe().iterator().hasNext());
            assertFalse(findMaryDoe().iterator().hasNext());
        }
        finally
        {
            connector.deleteRecord(RecordTypeEnum.EMPLOYEE, ref.getInternalId(), RecordIdType.INTERNAL);
        }
    }

    private Iterable<Record> findJohnDoe()
    {
        return connector.findRecords(SearchRecordTypeEnum.EMPLOYEE, "is(firstName, 'John'), is(lastName, 'Doe')");
    }

    private Iterable<Record> findMaryDoe()
    {
        return connector.findRecords(SearchRecordTypeEnum.EMPLOYEE, "is(firstName, 'Mary'), is(lastName, 'Doe')");
    }

    @Test
    public void findRecordJoinedSearch() throws Exception
    {
        assertNotNull(connector.findRecords(SearchRecordTypeEnum.EMPLOYEE,
            "is(email, 'john.doe@foobar.com'), is(userNotes.title, 'A note')"));
    }

    /**
     * Test that item availability queries work for existing inventory items
     */
    @Test
    public void getItemAvailability()
    {
        RecordRef inventoryItem = connector.addRecord(RecordTypeEnum.INVENTORY_ITEM,
            new HashMap<String, Object>()
            {
                {
                    put("isTaxable", false);
                    put("isOnline", true);
                    put("weight", 59.10);
                    put("weightUnit", ItemWeightUnit.G);
                    put("displayName", "A thing");
                    put("storeDisplayName", "A thing");
                    put("vendorName", "A vendor");
                    put("itemId", "Item");
                }
            });
        try
        {
            assertNotNull(connector.getItemAvailabilities(RecordTypeEnum.INVENTORY_ITEM,
                inventoryItem.getInternalId(), RecordIdType.INTERNAL, null));
        }
        finally
        {
            connector.deleteRecord(RecordTypeEnum.INVENTORY_ITEM, inventoryItem.getInternalId(),
                RecordIdType.INTERNAL);
        }
    }

    /***
     * Tests that a saved search can be executed This tests assumes there is at least
     * a saved search in the system - one of those provided as example to new
     * netsuite accounts.
     */
    @Test
    public void getSavedSearch()
    {

        RecordRef object = (RecordRef) connector.getSavedSearch(RecordTypeEnum.CUSTOMER).get(0);
        assertNotNull(connector.savedFindRecords(SearchRecordTypeEnum.CUSTOMER, object.getInternalId()));
    }

    /**
     * Tests that the invitation status of a calendar event can be updated
     */
    @Test
    public void updateInviteeStatus()
    {
        RecordRef event = connector.addRecord(RecordTypeEnum.CALENDAR_EVENT, new HashMap<String, Object>()
        {
            {
                put("title", "An importat event");
                put("location", "Pekin");
                put("startDate", new Date());
            }
        });
        connector.updateInviteeStatus(event.getInternalId(), RecordIdType.INTERNAL,
            CalendarEventAttendeeResponseEnum.DECLINED);
    }

    private RecordRef createEmployeeJohnDoe()
    {
        RecordRef recordRef = connector.addRecord(RecordTypeEnum.EMPLOYEE, new HashMap<String, Object>()
        {
            {
                put("fax", "159-945-56");
                put("firstName", "John");
                put("lastName", "Doe");
                put("isSalesRep", true);
                put("email", "john.doe@foobar.com");
                put("gender", Gender.MALE);
            }
        });
        return recordRef;
    }

    @Test
    public void asyncFindRecord() throws Exception
    {
        RecordRef employee = createEmployeeJohnDoe();
        try
        {
            AsyncStatusResult initialStatus = connector.asyncFindRecords(SearchRecordTypeEnum.EMPLOYEE,
                "is(firstName, 'John'), is(lastName, 'Doe')");
            assertNotNull(initialStatus);
            assertTrue(initialStatus.getStatus().isActive());
            AsyncStatusType status;
            do
            {
                Thread.sleep(500);
                status = connector.checkAsyncStatus(initialStatus.getJobId()).getStatus();
                System.out.println(status);
            }
            while (status.isActive());
            assertSame(AsyncStatusType.FINISHED, status);
            Iterable<Record> result = connector.getAsyncFindResult(initialStatus.getJobId());
            assertTrue(result.iterator().hasNext());
        }
        finally
        {
            connector.deleteRecord(RecordTypeEnum.EMPLOYEE, employee.getInternalId(), RecordIdType.INTERNAL);
        }
    }
}
